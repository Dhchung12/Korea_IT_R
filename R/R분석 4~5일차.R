# 과제.
math_scores <- c(76.7, 87.3, 94.2, 70.6)
names(math_scores) <- c("학생1", "학생2", "학생3", "학생4")
# 수학점수가 85점 이상인 학생들의 이름을 조회하기

math_scores
math_scores >= 85
math_scores[math_scores >= 85]

names(math_scores)
names(math_scores[1])
names(math_scores[math_scores >= 85])

# 과제.
# 3열에서 10보다 큰 요소 가져오기 -> 행 필터링
m1 <- matrix(data = 1:16, ncol = 4)
# 4행 4열
m1

# 논리 매트릭스가 생성된다
m1 > 10

# 논리 매트릭스를 통해 매트릭스를 인덱싱하면 결과가 벡터가 나온다
m1[m1 > 10]

# 매트릭스에서 3열을 가져온다
m1[, 3]
# 10보다 큰지 비교한다
m1[, 3] > 10
# 행 자리에 F, F, T, T 논리벡터를 전달하여 각 행에 논리값을 부여하고 T인 행들만 조회한다
m1[m1[, 3] > 10, 3]
m1[, 3][m1[,3] > 10]

# 3, 4열에서 10보다 큰 요소 찾기
m1[,c(3,4)][m1[,c(3,4)]>10]

# 매트릭스를 매트릭스로 인덱싱 할경우
# 숫자 매트릭스인 경우
mat1 <- matrix(1:4, 2)
idx <- matrix(c(1, 1, 2, 2), 2, byrow = T)

mat1
idx

# [1,1] [2,2]
mat1[idx]

idx2 <- matrix(c(1, 3, 1, 3), 2, byrow = T)
idx2

# [1,3], [1,3]
# 벡터와 달리 매트릭스는 행과 열의 길이를 인덱스 번호가 넘을수 없다
mat1[idx2]

idx3 <- matrix(c(1,1,1,2,2,2), 2, byrow = T)
idx3

mat1[idx3]
# 기준매트릭스[인덱스매트릭스]
# 인덱스 매트릭스가 숫자형태일때는 인덱스 매트릭스의 각 행의 요소가 기준 매트릭스의 행과 열의 인덱스 번호로 사용된다
?Extract

idx4 <- matrix(c(1,1,1,1,2,2,2,2), 2, byrow = T)
mat1[idx4]


# 논리 매트릭스인 경우 -> 논리벡터로 변환된다
# 기준매트릭스[인덱스 논리매트릭스]
# 기준벡터[인덱스 논리벡터]
# 매트릭스가 벡터로 변환되기 때문에 최종 결과값도 벡터로 나오게된다

l_idx <- mat1 %% 2 == 0
l_idx

# mat1 -> 벡터로 변환
# l_idx -> 논리 벡터로 변환
# mat1 벡터[l_idx 논리벡터]
mat1[l_idx]

v1 <- as.vector(mat1)
v2 <- as.vector(l_idx)
v1[v2]


# 과제.
# 아래의 코드를 실행했을때 1 37 NA 를 가져오게 됩니다
# 그 이유는 무엇인가요?
nums <- c(1, 3, NA, 10, 37)
nums[c(T, F, F, F, T, T)]

# 1 3 NA 10 37  NA
# T F  F  F  T  T
# 1          37 NA

# 기준 벡터와 사용하는 논리 벡터의 길이가 서로 다른 경우 
# 논리 벡터가 더 짧으면 -> 논리 벡터의 요소를 재사용
# 논리 벡터가 더 길면 -> 기준 벡터를 늘리고 NA 값을 채워서 사용

# 매트릭스의 정보
# 매트릭스의 간략한 정보를 보여준다(자료형, 행 인덱스번호, 열 인덱스번호, 총 데이터)
str(m1)

# 매트릭스의 총 데이터의 개수
length(m1)

# 매트릭스의 자료형
class(m1) # 자료구조의 자료형

mode(m1) # 데이터의 자료형
typeof(m1) # 데이터의 자료형

# 매트릭스 여부 확인
is.matrix(m1)
is.matrix(1:3)

# 벡터 여부 확인
is.vector(m1)
# 벡터로 변환
as.vector(m1)

# dimnames()
dimnames(m1) # 이름이 지정되어 있지 않아 NULL이 나온다

# 행의 이름
rownames(m1)
# 열의 이름
colnames(m1)

# 행의 개수, 열의 개수
dim(m1)

# 행의 개수
nrow(m1)

# 열의 개수
ncol(m1)

# 행의 이름 붙이기
rownames(m1) <- c("row1", "row2", "row3",
                  "row4")

rownames(m1)
m1

# 열의 이름 붙이기
# alt + enter : 코드를 실행하고 키보드 커서를 다음 라인으로 이동하지 않음
colnames(m1) <- c("col1", "col2", "col3",
                  "col4")

m1

# 행과 열에 이름을 부여하면 인덱스 번호가 아닌 이름으로 조회할수 있다

m1[1, ]
m1["row1", ]

dimnames(m1)

# 벡터의 추가
vec1 <- 1:5
vec1[6] <- 6
vec1

# vec1과 vec2를 연결하여 vec3를 생성하고 싶다
vec2 <- 10:15
vec1 + vec2

# 기존 벡터와 새로운 값을 연결하거나 새로운 벡터를 연결할때는 c() 함수를 사용한다
vec3 <- c(vec1, vec2)
vec3

c(vec3, 100)

c(m1, matrix(1:4, 2))

# 매트릭스의 사용
# 매트릭스는 벡터와 다르게 길이를 넘은 인덱스 번호를 사용하면 에러가 발생한다
# m1 : 4행 4열

m1[5, ]
m1[, 10]

m1
# 추가
# cbind() : 열추가
cbind(m1, 1:4)

# 추가하려는 벡터가 변수에 담겨있으면 행또는 열의 이름을 벡터명으로 자동 사용한다
col5 <- 1:4
cbind(m1, col5)

# rbind() : 행추가
rbind(m1, 10:13)
row5 <- 10:13
rbind(m1, row5)

help(rbind)
# 행렬끼리도 연결이 가능하지만 행이나 열의 개수가 동일해야 한다
rbind(m1, matrix(20:35, 4))

# 수정
m1[1, 1] <- 1000
m1

m1[2,] <- 99
m1

# 수정하려는 값의 개수와 행렬의 칸의 개수가 일치해야 한다
m1[3, ] <- 1:6

# 삭제
m1 <- m1[-2, ]
m1

# 매트릭스 연산
mat2 <- matrix(1:6, nrow =2)
# 2행 3열의 매트릭스
mat2

# 10이 6개 들어있는 벡터를 생성한다
mat3 <- matrix(rep(10, 6), nrow = 2)
mat3

# 산술 연산
# 매트릭스의 요소끼리 연산(원소 기반 연산)

mat2 + mat3
mat2 * mat3

# 매트릭스끼리는 서로 길이가 같아야 연산할수 있다
mat4 <- matrix(rep(10, 4), nrow = 2)
mat2 + mat4

mat5 <- matrix(rep(10, 6), ncol = 2)
mat5

# 행렬의 내적
mat2 %*% mat5

# 행렬의 외적
mat2 %o% mat5

# 전치행렬 -> 행과 열을 바꾼다
# 2행 3열 행렬
mat2
# 3행 2열 행렬
t(mat2)

# 배열 생성
arr1 <- array(1:20, dim = c(2, 2, 5))
# 2행 2열 매트릭스를 총 5면의 배열로 생성한다
arr1

arr2 <- array(1:24, dim = c(2, 3, 4))
# 2행 3열 매트릭스를 총 4면의 배열로 생성한다
arr2

arr3 <- array(1:24, dim = c(2))
arr3

attributes(arr3)

# array() 함수로 생성한 벡터는 기존에 만든 벡터와 다르다 -> array() 함수로 생성시 dim 속성을 가진다
test_vec <- 1:4
attributes(test_vec)

# 총 데이터의 개수와 dim 옵션의 숫자의 곱이 서로 일치하지 않으므로 나머지 데이터들은 누락된다
arr3 <- array(1:24, dim = c(2, 3))
arr3

# 벡터에 dim 옵션을 수정하기
test1 <- 1:16
dim(test1)
dim(test1) <- c(4, 2, 2)
test1

# 매트릭스에 dim 옵션을 수정하기
test2 <- matrix(1:8, ncol = 2)
dim(test2) <- c(2, 2, 2)
test2

# 배열의 요소 가져오기
arr2

arr2[1,2,3]
# 3면의 모든 행의 2열 데이터
arr2[,2,3]
# 3면의 모든 열의 1행 데이터
arr2[1,,3]
# 모든 면의 1행 2열 데이터 -> 벡터로 가져온다
arr2[1,2,]

# 데이터 1 -> arr2[1,1,1]
# 데이터 3 -> arr2[1,2,1]
# 콘솔창에 나오는 매트릭스에 표시된 인덱스 번호가 열과 면을 의미한다
arr2[1,,]

# 데이터 3 -> [1,2,1]
# 데이터 10 -> [2,2,2]
arr2[,2,]
# 3면에 있는 매트릭스를 그대로 조회한다
arr2[,,3]

# 매트릭스명[, 2:3] -> 모든행의 2열과 3열의 데이터를 조회한다
# 매트릭스 여러개를 조회해야 하므로 배열로 조회한다
arr2[,2:3,]


























